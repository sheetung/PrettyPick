# Auto generated by LangBot Plugin SDK.
# Please refer to https://docs.langbot.app/en/plugin/dev/tutor.html for more details.
from __future__ import annotations

import re
import httpx
import asyncio
import logging
from langbot_plugin.api.definition.components.common.event_listener import EventListener
from langbot_plugin.api.entities import events, context
from langbot_plugin.api.entities.builtin.platform import message as platform_message
from langbot_plugin.api.entities.builtin.provider import message as provider_message


class DefaultEventListener(EventListener):

    async def initialize(self):
        await super().initialize()
        self.logger = logging.getLogger(__name__)
        # 获取插件配置
        self.beauty_trigger = self.plugin.get_config().get("beauty_trigger", "看妹妹")
        self.image_count_limit = self.plugin.get_config().get("image_count_limit", 3)
        self.use_forward = self.plugin.get_config().get("use_forward", True)
        self.onebot_api_url = self.plugin.get_config().get("onebot_api_url", "http://127.0.0.1:3000")
        self.onebot_access_token = self.plugin.get_config().get("onebot_access_token", "")
        self.mmproxy = self.plugin.get_config().get("mmproxy", "s")

        # 如果启用合并转发，导入工具
        if self.use_forward:
            try:
                from utils.forward_message import ForwardMessageSender
                self.forward_sender = ForwardMessageSender(
                    http_url=self.onebot_api_url,
                    access_token=self.onebot_access_token if self.onebot_access_token else None
                )
            except ImportError:
                self.logger.warning("合并转发模块未找到，将使用普通消息发送")
                self.plugin.logger
                self.forward_sender = None
        else:
            self.forward_sender = None

        @self.handler(events.GroupMessageReceived)
        async def handler(event_context: context.EventContext):
            """处理群消息事件"""
            # 获取用户消息文本
            message_text = str(event_context.event.message_chain)

            # 检查是否包含触发词
            if not message_text.startswith(self.beauty_trigger):
                return

            # 解析请求的图片数量
            args = message_text[len(self.beauty_trigger):].strip()
            num_match = re.match(r'(\d+)', args)
            requested_count = 1
            if num_match:
                requested_count = int(num_match.group(1))

            # 限制最大图片数量
            actual_count = max(1, min(requested_count, self.image_count_limit))

            # 并发请求图片
            tasks = [self._fetch_beauty_image() for _ in range(actual_count)]
            results = await asyncio.gather(*tasks)

            # 检查是否需要使用合并转发
            if actual_count > 1 and self.use_forward and self.forward_sender:
                # 使用合并转发
                await self._send_forward(event_context, results, requested_count, self.image_count_limit)
            else:
                # 使用普通消息
                await self._send_normal(event_context, results, requested_count, self.image_count_limit)

    async def _fetch_beauty_image(self, max_retries: int = 3) -> str:
        """
        获取美女图片链接（带重试机制）

        Args:
            max_retries: 最大重试次数

        Returns:
            图片URL或错误信息
        """
        api_url = "https://3650000.xyz/api/?type=json&mode=1,3,5,8"

        # 配置代理（如果设置了 mmproxy）
        proxy = self.mmproxy if self.mmproxy else None

        for attempt in range(max_retries):
            try:
                async with httpx.AsyncClient(proxy=proxy, timeout=15.0) as client:
                    response = await client.get(api_url)
                    if response.status_code == 200:
                        response_data = response.json()
                        if response_data.get("code") == 200:
                            return response_data.get("url")
                        else:
                            error_msg = f"API异常 code={response_data.get('code')}"
                    else:
                        error_msg = f"状态码错误 {response.status_code}"
            except httpx.RequestError as e:
                error_msg = f"网络错误: {str(e)}"
            except Exception as e:
                error_msg = f"未知错误: {str(e)}"

            # 如果是最后一次重试，返回错误信息
            if attempt == max_retries - 1:
                self.logger.warning(f"获取图片失败 (重试{max_retries}次): {error_msg}")
                return error_msg

            # 等待后重试
            await asyncio.sleep(1)

        return "获取图片失败"

    async def _send_forward(
        self,
        event_context: context.EventContext,
        results: list,
        requested_count: int,
        limit: int
    ):
        """
        使用合并转发发送图片

        Args:
            event_context: 事件上下文
            results: 图片URL列表
            requested_count: 用户请求的数量
            limit: 限制数量
        """
        messages = []

        # 如果请求超过限制，添加提示消息
        if requested_count > limit:
            messages.append({
                "content": [
                    {
                        "type": "text",
                        "data": {"text": f"大人您看了{requested_count}下，但是不行哦，只能看{limit}下"}
                    }
                ]
            })

        # 添加图片消息
        for i, result in enumerate(results, 1):
            if result and result.startswith('http'):
                messages.append({
                    "content": [
                        {
                            "type": "image",
                            "data": {"file": result}
                        }
                    ]
                })
            else:
                messages.append({
                    "content": [
                        {
                            "type": "text",
                            "data": {"text": f"[失败] 第{i}张图片: {result}"}
                        }
                    ]
                })

        # 发送合并转发消息
        try:
            result = await self.forward_sender.send_forward(
                group_id=event_context.event.launcher_id,
                messages=messages,
                prompt="美女图片",
                summary=f"共{len(results)}张图片",
                nickname="PrettyPick",
                mode="multi"
            )

            if not result.get('success'):
                self.logger.error(f"合并转发发送失败: {result.get('error')}")
                # 如果合并转发失败，降级使用普通消息
                await self._send_normal(event_context, results, requested_count, limit)
        except Exception as e:
            self.logger.error(f"合并转发发送异常: {str(e)}")
            # 如果合并转发失败，降级使用普通消息
            await self._send_normal(event_context, results, requested_count, limit)

    async def _send_normal(
        self,
        event_context: context.EventContext,
        results: list,
        requested_count: int,
        limit: int
    ):
        """
        使用普通消息发送图片

        Args:
            event_context: 事件上下文
            results: 图片URL列表
            requested_count: 用户请求的数量
            limit: 限制数量
        """
        message_chain = []

        # 如果请求超过限制，添加提示
        if requested_count > limit:
            message_chain.append(
                platform_message.Plain(text=f"大人您看了{requested_count}下，但是不行哦，只能看{limit}下\n\n")
            )

        # 添加图片
        for i, result in enumerate(results, 1):
            if result and result.startswith('http'):
                message_chain.append(platform_message.Image(url=result))
                # 多张图片时添加分隔
                if len(results) > 1 and i < len(results):
                    message_chain.append(platform_message.Plain(text="\n"))
            else:
                message_chain.append(
                    platform_message.Plain(text=f"[失败] 第{i}张图片: {result}\n")
                )

        # 发送消息
        await event_context.reply(
            platform_message.MessageChain(message_chain)
        )
